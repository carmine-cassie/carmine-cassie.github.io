<!doctype html>
<html lang="en" data-theme="light">
  <head>
    <meta charset="utf-8" />
    <meta name='viewport' content='width=device-width'/>
    <title>Portfolio</title>

    <link rel="stylesheet" href="/assets/css/portfolio.css">
    <script src="/assets/js/theme.js" defer></script>

  </head>

  <body>
    <div class="main-paper"><div class="main-paper-padding">
      <button data-theme-toggle>
        <!-- Icons from pixelarticons.com -->
        <svg xmlns="http://www.w3.org/2000/svg" fill="currentColor" class="dark-icon" viewBox="0 0 24 24">
          <path d="M20 0h2v2h2v2h-2v2h-2V4h-2V2h2V0ZM8 4h8v2h-2v2h-2V6H8V4ZM6 8V6h2v2H6Zm0 8H4V8h2v8Zm2 2H6v-2h2v2Zm8 0v2H8v-2h8Zm2-2v2h-2v-2h2Zm-2-4v-2h2V8h2v8h-2v-4h-2Zm-4 0h4v2h-4v-2Zm0 0V8h-2v4h2Zm-8 6H2v2H0v2h2v2h2v-2h2v-2H4v-2Z"/>
        </svg>
        <svg fill="currentColor" xmlns="http://www.w3.org/2000/svg" class="light-icon" viewBox="0 0 24 24">
          <path d="M13 0h-2v4h2V0ZM0 11v2h4v-2H0Zm24 0v2h-4v-2h4ZM13 24h-2v-4h2v4ZM8 6h8v2H8V6ZM6 8h2v8H6V8Zm2 10v-2h8v2H8Zm10-2h-2V8h2v8Zm2-14h2v2h-2V2Zm0 2v2h-2V4h2Zm2 18h-2v-2h2v2Zm-2-2h-2v-2h2v2ZM4 2H2v2h2v2h2V4H4V2ZM2 22h2v-2h2v-2H4v2H2v2Z"/>
        </svg>
      </button>

      <p style="font-family:toshibatx"><a href="/">Home</a> Â» </p>

      <h1>Portfolio</h1>

      <h2>Canva: Data-Butler</h2>
      <p>During my internship at Canva, I worked with another intern to develop and deploy a proof-of-concept database access platform called Data-Butler. The project would improve security, as rather than requesting up-front permission to tunnel into a data store with coarse-grained permissions, an engineer can request approval through a web interface to run a specific, fine-grained query.</p>
      <p>The tech stack on Data-Butler had a lot going on - best explained by breaking down what happens when a user requests an operation. The frontend, written in React, makes a POST request to the API of the backend HTTP server, which is written in Go. The backend persists information about the operation in an AWS RDS, and then enqueues the operation in an AWS ElastiCache queue. Then, an asynchronous worker, also written in Go, dequeues the operation from the ElastiCache queue, retrieves information from the RDS, assumes the appropriate AWS roles to reach the target database, and performs the operation! The project was deployed using a combination of Bazel, Terraform, and in-house tooling.</p>

      <h2>TTGSoc: Event Pipeline Bot</h2>
      <p>The UNSW Tabletop Games Society runs a lot of events, which means that their executive team has a lot of paperwork to do! As part of my role on the IT Subcommittee at TTGSoc, I worked to develop a system to ease the workload. Working in a small team, we took an agile approach to get our systems up and running as soon as possible.</p>
      <p>The project is built in Python, containerised and deployed using Docker, with a PostgreSQL backend. It functions by interacting with a couple APIs, performing tasks that previously would be done by hand. When an event is created on Discord, the system creates a Google Form to track attendance for the event. When the event starts on Discord, the system uses a link-shortening service's API to point our pre-existing link to the attendance form for that event. This means we can show the same QR code at every event</p>

      <h2>UNSW: DNS Resolver</h2>
      <p>As an assignment for the course <q>Computer Networks and Applications</q>, I wrote a DNS resolver using Python. I really enjoyed being able to follow the super specific specifications from the 80s! I found it really remarkable that DNS resolvers are real internet infrastructure that I rely on thousands of times a day, and I was able to try my hand at implementing one.</p>

      <h2>UNSW: Turtle Language Interpreter</h2>
      <p>As an assignment for the course <q>Solving Modern Programming Problems with Rust</q>, I wrote an interpreter for the educational programming language Logo. It was really fun to design my strategy, especially building data types to work elegantly with Rust's eccentric systems.</p>
      <p>I ended up parsing each line of logo code into an Abstract Syntax Tree, and then evaluating them recursively. I enjoyed getting to make use of my knowledge of assembly language, as I processed control flow down to assembly-style branch and jump instructions.</p>

    </div></div>
  </body>
</html>
